
/* lib/terminal/test/application/browser - The functions necessary to run browser test automation. */

import { exec } from "child_process";

import common from "../../../common/common.js";
import error from "../../utilities/error.js";
import humanTime from "../../utilities/humanTime.js";
import ipList from "../../utilities/ipList.js";
import log from "../../utilities/log.js";
import remove from "../../commands/library/remove.js";
import sender from "../../server/transmission/sender.js";
import time from "../../utilities/time.js";
import transmit_http from "../../server/transmission/transmit_http.js";
import transmit_ws from "../../server/transmission/transmit_ws.js";
import vars from "../../utilities/vars.js";

import filePathDecode from "./browserUtilities/file_path_decode.js";
import machines from "./browserUtilities/machines.js";
import test_device from "../samples/browser_device.js";
import test_self from "../samples/browser_self.js";
import test_user from "../samples/browser_user.js";

let finished:boolean = false,
    tests:test_browserItem[];
const defaultCommand:commands = vars.environment.command,
    defaultAddresses:transmit_addresses_IP = vars.network.addresses,
    defaultStorage:string = vars.path.settings,
    /**
     * Methods associated with the browser test automation logic.
     * ```typescript
     * interface module_test_browserApplication {
     *     args       : config_test_browserExecute; // Default configuration object available to the entire test browser library. Over written by a configuration object of same type passed into the *methods.execute* method.
     *     exitMessage: string;                     // Stores an exit message string for availability to the entirety of the test browser application because this messaging is generated by one method and distributed by another.
     *     fail       : boolean;                    // Stores the pass/fail status for messaging to the callback.
     *     index      : number;                     // Stores the current test item index number.
     *     ip         : string;                     // Stores the IP address of the target machine for the current test index.
     *     methods: {
     *         close             : (data:service_testBrowser) => void;        // Sends a single that tests are complete and the respective browser window should close on the local device.
     *         delay             : (config:config_test_browserDelay) => void; // Provides a single point of logic to handle delays regardless of the cause, duration, or associated messaging.
     *         execute           : (args:config_test_browserExecute) => void; // Entry point to browser test automation that prepares the environment on the local device and tells the remote machines to reset their environments.
     *         exit              : (index:number) => void;                    // Closes out testing on the local device and informs remote machines that testing has concluded with the corresponding messaging and a single to close their respective browser window.
     *         iterate           : (index:number) => void;                    // Validates the next browser test is properly formed and then either sends it to a browser on the local device or to the correct machine.
     *         request           : (item:service_testBrowser) => void;        // Receives a test item on a remote machine for distribution to its browser for execution.  The result is sent back using *methods.respond*.
     *         ["reset-browser"] : () => void;                                // Sends a reset request to the browser of any given machine to prepare to execute tests.
     *         ["reset-complete"]: (item:service_testBrowser) => void;        // Instructions the given machine to remove artifacts from a prior test cycle. The local machine will then issue *reset-request* to remote machines.
     *         ["reset-request"] : (item:service_testBrowser) => void;        // Sends a reset request to remote machines informing them to reset their environment and prepare to listen for incoming test items. Method executed from *methods.execute*.
     *         respond           : (item:service_testBrowser) => void;        // On a remote machine receives test execution messaging from its local browser for transfer back to the originating machine.
     *         result            : (item:service_testBrowser) => void;        // Evaluation result provided by a browser and transforms that data into messaging for a human to read.
     *         route             : (socketData:socketData) => void;           // Entry point to the browser test automation library on all remote machines. Tasks are routed to the correct method based upon the action specified.
     *         send              : (testItem:service_testBrowser, callback:() => void) => void; // Encapsulates the transmission logic to send tests to the local browser.
     *     };
     *     name        : string; // indicates identity of the local machine
     *     port        : number; // Stores the port number of the target machine for the current test index.
     *     remoteAgents: number; // Counts the remote agents that are reporting a ready status before executing the first test.
     * }
     * ``` */
    browser:module_test_browserApplication = {
        args: {
            callback: function terminal_test_application_browser_callback():void {
                return;
            },
            demo: false,
            mode: "self",
            noClose: false
        },
        exitMessage: "",
        fail: false,
        index: -1,
        ip: "",
        methods: {
            close: function terminal_test_application_browser_close(data:service_testBrowser):void {
                const close:service_testBrowser = {
                    action: "close",
                    exit: data.exit,
                    index: -1,
                    result: [],
                    test: {
                        interaction: null,
                        machine: browser.name,
                        name: "close",
                        unit: null
                    }
                };
                browser.methods.send(close, null);
                log([data.exit]);
            },
            delay: function terminal_test_application_browser_delay(config:config_test_browserDelay):void {
                const wait:number = (config.browser === true)
                        ? 0
                        : config.delay,
                    seconds:string = (config.delay / 1000).toString(),
                    plural:string = (config.delay === 1000)
                        ? ""
                        : "s";
                if (config.delay > 0 && config.message !== "demo") {
                    log([`${humanTime(false)}Delaying for ${vars.text.cyan + seconds + vars.text.none} second${plural}: ${vars.text.cyan + config.message + vars.text.none}`]);
                }
                setTimeout(config.action, wait);
            },
            execute: function terminal_test_application_browser_execute(args:config_test_browserExecute):void {
                const removePath:string = `${vars.path.project}lib${vars.path.sep}terminal${vars.path.sep}test${vars.path.sep}storageTest${vars.path.sep}temp`;

                log.title(`Browser Tests - ${args.mode}`, true);
                browser.args = args;
                if (args.mode === "self") {
                    tests = test_self;
                } else if (args.mode === "device") {
                    vars.settings.secure = true;
                    tests = test_device;
                } else if (args.mode === "user") {
                    vars.settings.secure = true;
                    tests = test_user;
                } else if (args.mode === "remote") {
                    vars.settings.secure = true;
                }
                vars.environment.command = "test_browser";
                vars.network.addresses = {
                    IPv4: [machines[browser.name].ip],
                    IPv6: []
                };
                vars.test.browser = {
                    action: (args.mode === "remote")
                        ? "nothing"
                        : "reset-request",
                    exit: (vars.settings.verbose === true)
                        ? "verbose"
                        : "",
                    index: -1,
                    result: [],
                    test: null
                };
                remove(removePath, [`${removePath + vars.path.sep}temp.txt`], function terminal_test_application_browser_execute_remove():void {
                    const agents = function terminal_test_application_browser_execute_agents():void {
                            const list:string[] = Object.keys(machines),
                                listLength:number = list.length;
                            let index:number = 0;
                            log(["Preparing remote machines"]);
                            vars.test.browser.test = {
                                interaction: null,
                                machine: null,
                                name: "",
                                unit: null
                            };
                            do {
                                if (list[index] !== browser.name) {
                                    vars.test.browser.test.machine = list[index];
                                    browser.methods.send(vars.test.browser, null);
                                }
                                index = index + 1;
                            } while (index < listLength);
                        },
                        reset = function terminal_test_application_browser_execute_reset():void {
                            browser.methods["reset-request"]({
                                action: "result",
                                exit: "",
                                index: 0,
                                result: [],
                                test: tests[0]
                            });
                        },
                        remote = function terminal_test_application_browser_execute_remoteServer():void {
                            const list:string[] = ipList(null, true, ` ${vars.text.angry}*${vars.text.none} `);
                            list.splice(0, 0, `${vars.text.cyan}Environment ready. Listening for instructions on these addresses:${vars.text.none}`);
                            log(list);
                        };
                    vars.test.type = `browser_${args.mode}` as test_listType;
                    transmit_http.server({
                        browser: false,
                        host: "",
                        port: -1,
                        test: true
                    },
                    {
                        agent: "",
                        agentType: "device",
                        callback: (args.mode === "remote")
                            ? remote
                            : (args.mode === "self")
                                ? reset
                                : agents
                    });
                });
            },
            exit: function terminal_test_application_browser_exit(index:number):void {
                if (finished === true) {
                    return;
                }
                finished = true;
                const close:service_testBrowser = {
                        action: (browser.args.noClose === true)
                            ? "nothing"
                            : "close",
                        exit: browser.exitMessage,
                        index: index,
                        result: [],
                        test: {
                            interaction: null,
                            machine: browser.name,
                            name: "close",
                            unit: null
                        }
                    },
                    exitMessage:string[] = [
                        browser.exitMessage,
                        "",
                        `${vars.text.underline}Network Transmissions${vars.text.none}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan}HTTP Receive${vars.text.none} - ${common.commas(vars.network.count.http.receive)}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan}HTTP Send${vars.text.none}    - ${common.commas(vars.network.count.http.send)}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan}WS   Receive${vars.text.none} - ${common.commas(vars.network.count.ws.receive)}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan}WS   Send${vars.text.none}    - ${common.commas(vars.network.count.ws.send)}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan + vars.text.bold + vars.text.underline}Total${vars.text.none}        - ${common.commas(vars.network.count.http.receive + vars.network.count.http.send + vars.network.count.ws.receive + vars.network.count.ws.send)}`,
                        "",
                        `${vars.text.underline}Network Transmission Size (Bytes)${vars.text.none}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan}HTTP Receive${vars.text.none} - ${common.commas(vars.network.size.http.receive)}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan}HTTP Send${vars.text.none}    - ${common.commas(vars.network.size.http.send)}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan}WS   Receive${vars.text.none} - ${common.commas(vars.network.size.ws.receive)}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan}WS   Send${vars.text.none}    - ${common.commas(vars.network.size.ws.send)}`,
                        `${vars.text.angry}*${vars.text.none} ${vars.text.cyan + vars.text.bold + vars.text.underline}Total${vars.text.none}        - ${common.commas(vars.network.size.http.receive + vars.network.size.http.send + vars.network.size.ws.receive + vars.network.size.ws.send)}`
                    ],
                    closing = (browser.args.noClose === true)
                        ? function terminal_test_application_browser_exit_noClose():void {
                            exitMessage.push("\u0007");
                            log(exitMessage, true);
                        }
                        : function terminal_test_application_browser_exit_closing():void {
                            browser.methods.send(close, null);
                            browser.methods.delay({
                                action: function terminal_test_application_browser_exit_closing_delay():void {
                                    browser.index = -1;
                                    vars.environment.command = defaultCommand;
                                    vars.network.addresses = defaultAddresses;
                                    vars.path.settings = defaultStorage;
                                    vars.test.browser = null;
                                    browser.args.callback(`Browser ${browser.args.mode} Test`, exitMessage, browser.fail);
                                },
                                browser: false,
                                delay: 1000,
                                message: "Closing out the test environment."
                            });
                        };
                if (browser.args.mode === "device" || browser.args.mode === "user") {
                    let count:number = 0;
                    const agents:string[] = Object.keys(machines);
                    agents.forEach(function terminal_test_application_browser_exit_agents(name:string):void {
                        const callback = function terminal_test_application_browser_exit_callback():void {
                            count = count + 1;
                            if (count === agents.length - 1) {
                                closing();
                            }
                        };
                        close.test.machine = name;
                        browser.methods.send(close, callback);
                    });
                } else {
                    closing();
                }
            },
            iterate: function terminal_test_application_browser_iterate(index:number):void {
                // not writing to settings
                if (finished === true) {
                    return;
                }
                let delayMessage:string = "",
                    delayBrowser:boolean = false;
                const logs:string[] = [
                        `Test ${index + 1} malformed: ${vars.text.angry + tests[index].name + vars.text.none}`,
                        ""
                    ],
                    wait:number = (function terminal_test_application_browser_iterate_wait():number {
                        const interactionLength:number = (tests[index].interaction === null)
                            ? 0
                            : tests[index].interaction.length;
                        let a:number = interactionLength,
                            value:number = 0,
                            count:number = 0;
                        if (a > 0) {
                            do {
                                a = a - 1;
                                if (tests[index].interaction[a].event === "wait") {
                                    value = Number(tests[index].interaction[a].value);
                                    if (isNaN(value) === false) {
                                        count = count + value;
                                    }
                                }
                            } while (a > 0);
                        }
                        value = 2000;
                        if (interactionLength > 0 && tests[index].interaction !== null && tests[index].interaction[0].event === "refresh" && tests[index + 1] !== undefined && tests[index + 1].machine !== browser.name && count < value) {
                            delayMessage = "Providing remote machine browser time before a refresh.";
                            return value;
                        }
                        if (browser.args.demo === true && count < 501) {
                            return 500;
                        }
                        if (count > 0) {
                            delayBrowser = true;
                        }
                        return count;
                    }()),
                    waitText = function terminal_test_application_browser_iterate_waitText(machine:string):string {
                        return (delayMessage === "" && wait > 0)
                            ? `Pausing for 'wait' event in browser on machine ${machine}.`
                            : delayMessage;
                    },
            
                    // determine if non-interactive events have required matching data properties
                    validate = function terminal_test_application_browser_iterate_validate():boolean {
                        let a:number = 0;
                        const length:number = (tests[index].interaction === null)
                                ? 0
                                : tests[index].interaction.length,
                            eventName = function terminal_test_application_browser_iterate_validate_eventName(property:string):string {
                                return `   ${vars.text.angry}*${vars.text.none} Interaction ${a + 1} has event ${vars.text.cyan}setValue${vars.text.none} but no ${vars.text.angry + property + vars.text.none} property.`;
                            };
                        if (tests[index].delay === undefined && tests[index].unit.length < 1) {
                            logs.push("Test does not contain a delay test or test instances in its test array.");
                            return false;
                        }
                        if (length > 0) {
                            do {
                                if ((tests[index].interaction[a].event === "setValue" || tests[index].interaction[a].event === "keydown" || tests[index].interaction[a].event === "keyup") && tests[index].interaction[a].value === undefined) {
                                    logs.push(eventName("value"));
                                } else if (tests[index].interaction[a].event === "move" && tests[index].interaction[a].coords === undefined) {
                                    logs.push(eventName("coords"));
                                }
                                a = a + 1;
                            } while (a < length);
                        }
                        if (logs.length < 3) {
                            return true;
                        }
                        return false;
                    };
                // delay is necessary to prevent a race condition
                // * about 1 in 10 times this will fail following event "refresh"
                // * because vars.test.browser is not updated to methodGET library fast enough
                if (validate() === true) {
                    const callback = (tests[index].machine === browser.name)
                        ? null
                        : function terminal_test_application_browser_iterate_httpClient():void {
                            if (finished === true) {
                                browser.methods.exit(index);
                            }
                        };
                    vars.test.browser = {
                        action: "result",
                        exit: "",
                        index: index,
                        result: [],
                        test: tests[index]
                    };
                    if (tests[index].machine === browser.name) {
                        tests[index] = filePathDecode(tests[index], "") as test_browserItem;
                    } else {
                        vars.test.browser.action = "request";
                    }
                    browser.methods.delay({
                        action: function terminal_test_application_browser_iterate_selfDelay():void {
                            browser.methods.send(vars.test.browser, callback);
                        },
                        browser: delayBrowser,
                        delay: wait,
                        message: waitText(tests[index].machine)
                    });
                } else {
                    log(logs, true);
                    if (browser.args.noClose === false) {
                        process.exit(1);
                    }
                }
            },
            request: function terminal_test_application_browser_request(item:service_testBrowser):void {
                item.test = filePathDecode(item.test, "") as test_browserItem;
                const route:service_testBrowser = {
                    action: "respond",
                    exit: "",
                    index: item.index,
                    result: [],
                    test: item.test
                };
                item.action = "respond";
                vars.test.browser = item;
                browser.methods.send(route, null);
            },
            ["reset-browser"]: function terminal_test_application_browser_resetBrowser():void {
                if (browser.args.mode === "remote") {
                    const payload:service_testBrowser = {
                        action: "reset-complete",
                        exit: "",
                        index: -1,
                        result: [],
                        test: {
                            interaction: null,
                            machine: "self",
                            name: `reset-browser-${browser.name}`,
                            unit: null
                        }
                    };
                    browser.methods.send(payload, null);
                }
            },
            ["reset-complete"]: function terminal_test_application_browser_resetComplete(item:service_testBrowser):void {
                const list:string[] = Object.keys(machines),
                    listLength:number = list.length - 1,
                    boldGreen:string = vars.text.green + vars.text.bold,
                    color:string = (browser.remoteAgents === listLength - 1)
                        ? boldGreen
                        : vars.text.angry;
                browser.remoteAgents = browser.remoteAgents + 1;
                if (browser.remoteAgents < listLength + 1) {
                    log([`Received ready state from ${color + browser.remoteAgents + vars.text.none} of ${boldGreen + listLength + vars.text.none} total machines (${item.test.name.replace("reset-browser-", "")}).`]);
                }
                if (browser.remoteAgents === listLength) {
                    log(["", "Executing tests"]);
                    browser.methods["reset-request"]({
                        action: "result",
                        exit: "",
                        index: 0,
                        result: [],
                        test: tests[0]
                    });
                }
            },
            ["reset-request"]: function terminal_test_application_browser_resetRequest(item:service_testBrowser):void {
                const browserLaunch = function terminal_test_application_browser_resetRequest_readdir_browserLaunch():void {
                        const keyword:string = (process.platform === "darwin")
                                ? "open"
                                : (process.platform === "win32")
                                    ? "start"
                                    : "xdg-open",
                            port:string = (vars.network.ports.http === 443)
                                ? ""
                                : `:${String(vars.network.ports.http)}`,
                            verboseFlag:string = (item.exit === "verbose" || (browser.args.mode !== "remote" && vars.settings.verbose === true))
                                ? "test_browser_verbose"
                                : "test_browser",
                            path:string = `https://${vars.network.domain[0] + port}/?${verboseFlag}`,
                            // execute a browser by file path to the browser binary
                            browserCommand:string = (process.argv.length > 0 && (process.argv[0].indexOf("\\") > -1 || process.argv[0].indexOf("/") > -1))
                                ? (function terminal_test_application_browser_resetRequest_readdir_browserLaunch_browserCommand():string {
                                    if (process.platform === "win32") {
                                        // yes, this is ugly.  Windows old cmd shell doesn't play well with file paths
                                        process.argv[0] = `${process.argv[0].replace(/\\/g, "\"\\\"").replace("\"\\", "\\") + "\""}`;
                                    } else {
                                        process.argv[0] = `"${process.argv[0]}"`;
                                    }
                                    if (process.argv.length > 1) {
                                        return `${keyword} ${process.argv[0]} ${path} "${process.argv.slice(1).join(" ")}"`;
                                    }
                                    return `${keyword} ${process.argv[0]} ${path}`;
                                }())
                                : `${keyword} ${path}`,
                            child = function terminal_test_application_browser_resetRequest_readdir_browserLaunch_child(errs:Error, stdout:string, stderr:Buffer | string):void {
                                if (errs !== null) {
                                    error([errs.toString()]);
                                    return;
                                }
                                if (stdout !== "") {
                                    log([stdout]);
                                }
                                if (stderr !== "") {
                                    log([stderr.toString()]);
                                }
                            };
                        exec(browserCommand, {
                            cwd: vars.path.project
                        }, child);
                    },
                    start = function terminal_test_application_browser_resetRequest_readdir_start():void {
                        let timeStore:[string, number] = time("Resetting Test Environment", false, 0);
                        log(["", "", timeStore[0]]);
                        vars.settings.device = {};
                        vars.settings.user = {};
                        remove(vars.path.settings, [`${vars.path.settings}temp.txt`], function terminal_test_application_browser_resetRequest_readdir_remove():void {
                            browserLaunch();
                        });
                    };
                if (browser.args.mode === "remote") {
                    const close:service_testBrowser = {
                        action: "close",
                        exit: "",
                        index: -1,
                        result: [],
                        test: {
                            interaction: null,
                            machine: browser.name,
                            name: "reset-request",
                            unit: null
                        }
                    };
                    vars.test.browser = item;
                    browser.methods.send(close, null);
                    browser.methods.delay({
                        action: start,
                        browser: false,
                        delay: 2000,
                        message: "Delaying to close any open browsers."
                    });
                } else {
                    item.action = "result";
                    vars.test.browser = item;
                    start();
                }
            },
            respond: function terminal_test_application_browser_respond(item:service_testBrowser): void {
                const route:service_testBrowser = {
                    action: "result",
                    exit: "",
                    index: item.index,
                    result: item.result,
                    test: {
                        interaction: null,
                        machine: browser.name,
                        name: "result",
                        unit: null
                    }
                };
                vars.test.browser.action = "nothing";
                browser.methods.send(route, null);
            },
            result: function terminal_test_application_browser_result(item:service_testBrowser):void {
                if (finished === true) {
                    return;
                }
                let a:number = 0,
                    falseFlag:boolean = false;
                const result: [boolean, string, string][] = item.result,
                    index:number = item.index,
                    length:number = result.length,
                    delay:boolean = (tests[index].unit.length === 0),
                    completion = function terminal_test_application_browser_result_completion(pass:boolean):void {
                        const plural:string = (tests.length === 1)
                                ? ""
                                : "s",
                            totalTests:number = (function terminal_test_application_browser_result_completion_total():number {
                                // gathers a total count of tests
                                let aa:number = tests.length,
                                    bb:number = 0;
                                do {
                                    aa = aa - 1;
                                    bb = bb + tests[aa].unit.length;
                                    if (tests[aa].delay !== undefined) {
                                        bb = bb + 1;
                                    }
                                } while (aa > 0);
                                return bb;
                            }()),
                            passPlural:string = (index === 1)
                                ? ""
                                : "s",
                            exitMessage:string = (pass === true)
                                ? `${humanTime(false) + vars.text.green + vars.text.bold}Passed${vars.text.none} all ${totalTests} evaluations from ${index + 1} test${passPlural}.`
                                : `${humanTime(false) + vars.text.angry}Failed${vars.text.none} on test ${vars.text.angry + (index + 1) + vars.text.none}: "${vars.text.cyan + tests[index].name + vars.text.none}" out of ${tests.length} total test${plural} and ${totalTests} evaluations.`;
                        browser.exitMessage = exitMessage;
                        browser.methods.exit(index);
                        browser.fail = true;
                    },
                    summary = function terminal_test_application_browser_result_summary(pass:boolean):string {
                        const resultString:string = (pass === true)
                                ? `${vars.text.green}Passed`
                                : `${vars.text.angry}Failed`;
                        return `${humanTime(false) + resultString} ${browser.args.mode} ${index + 1}: ${vars.text.none + tests[index].name}`;
                    },
                    buildNode = function terminal_test_application_Browser_result_buildNode(config:test_browserTest, elementOnly:boolean):string {
                        let b:number = 0;
                        const node:browserDOM[] = config.node,
                            property:string[] = config.target,
                            nodeLength:number = node.length,
                            propertyLength:number = property.length,
                            output:string[] = (config.target[0] === "window")
                                ? []
                                : ["document"];
                        if (nodeLength > 0) {
                            do {
                                output.push(".");
                                output.push(node[b][0]);
                                if (node[b][1] !== null) {
                                    output.push("(\"");
                                    output.push(node[b][1]);
                                    output.push("\")");
                                }
                                if (node[b][2] !== null) {
                                    output.push("[");
                                    output.push(node[b][2].toString());
                                    output.push("]");
                                }
                                b = b + 1;
                            } while (b < nodeLength);
                        }
                        if (config.type === "element" || elementOnly === true) {
                            return output.join("");
                        }
                        if (config.type === "attribute") {
                            output.push(".");
                            output.push("getAttribute(\"");
                            output.push(config.target[0]);
                            output.push("\")");
                        } else if (config.type === "property") {
                            b = 0;
                            do {
                                output.push(".");
                                output.push(config.target[b]);
                                b = b + 1;
                            } while (b < propertyLength);
                        }
                        return output.join("");
                    },
                    testString = function terminal_test_application_browser_result_testString(pass:boolean, config:test_browserTest):string {
                        const valueStore:primitive = config.value,
                            valueType:string = typeof valueStore,
                            value = (valueStore === null)
                                ? "null"
                                : (valueType === "string")
                                    ? `"${valueStore}"`
                                    : String(valueStore),
                            star:string = `   ${vars.text.angry}*${vars.text.none} `,
                            resultString:string = (pass === true)
                                ? `${vars.text.green}Passed:`
                                : (config === tests[index].delay)
                                    ? `${vars.text.angry}Failed (delay timeout):`
                                    : `${vars.text.angry}Failed:`,
                            qualifier:string = (config.qualifier === "begins")
                                ? (pass === true)
                                    ? "begins with"
                                    : `${vars.text.angry}does not begin with${vars.text.none}`
                                : (config.qualifier === "contains")
                                    ? (pass === true)
                                        ? "contains"
                                        : `${vars.text.angry}does not contain${vars.text.none}`
                                    : (config.qualifier === "ends")
                                        ? (pass === true)
                                            ? "ends with"
                                            : `${vars.text.angry}does not end with${vars.text.none}`
                                        : (config.qualifier === "greater")
                                            ? (pass === true)
                                                ? "is greater than"
                                                : `${vars.text.angry}is not greater than${vars.text.none}`
                                            : (config.qualifier === "is")
                                                ? (pass === true)
                                                    ? "is"
                                                    : `${vars.text.angry}is not${vars.text.none}`
                                                : (config.qualifier === "lesser")
                                                    ? (pass === true)
                                                        ? "is less than"
                                                        : `${vars.text.angry}is not less than${vars.text.none}`
                                                    : (config.qualifier === "not")
                                                        ? (pass === true)
                                                            ? "is not"
                                                            : `${vars.text.angry}is${vars.text.none}`
                                                        : (pass === true)
                                                            ? "does not contain"
                                                            : `${vars.text.angry}contains${vars.text.none}`,
                            nodeString = `${vars.text.none} ${buildNode(config, false)} ${qualifier} ${value.replace(/^"/, "").replace(/"$/, "")}`;
                        return star + resultString + nodeString;
                    },
                    failureMessage = function terminal_test_application_browser_result_failureMessage():void {
                        if (result[a][2] === "error") {
                            const error:string = result[a][1]
                                .replace("{\"file\":"   , `{\n    "${vars.text.cyan}file${vars.text.none}"   :`)
                                .replace(",\"column\":" , `,\n    "${vars.text.cyan}column${vars.text.none}" :`)
                                .replace(",\"line\":"   , `,\n    "${vars.text.cyan}line${vars.text.none}"   :`)
                                .replace(",\"message\":", `,\n    "${vars.text.cyan}message${vars.text.none}":`)
                                .replace(",\"stack\":\"", `,\n    "${vars.text.cyan}stack${vars.text.none}"  :\n        `)
                                .replace(/\\n/g, "\n        ")
                                .replace(/@http/g, "  -  http")
                                .replace(/\s*"\s*\}$/, "\n}");
                            failure.push(`     ${vars.text.angry}JavaScript Error${vars.text.none}\n${error}`);
                        } else if (result[a][1].indexOf("Bad test. ") === 0) {
                            const segments:string[] = result[a][1].split(": [");
                            failure.push(`     ${segments[0].replace("Bad test.", `${vars.text.angry}Bad test.${vars.text.none}`)}.`);
                            if (segments.length > 1) {
                                failure.push(`     Provided: ${vars.text.angry}[${segments[1] + vars.text.none}`);
                            }
                            failure.push(`     ${vars.text.cyan + result[a][2] + vars.text.none}`);
                        } else if ((delay === false && result[a][2] === buildNode(tests[index].unit[a], true)) || (delay === true && result[a][2] === buildNode(tests[index].delay, true))) {
                            failure.push(`     ${vars.text.green}Actual value:${vars.text.none}\n        ${vars.text.angry + result[a][1].replace(/^"/, "").replace(/"$/, "").replace(/\\"/g, "\"") + vars.text.none}`);
                        } else if ((delay === false && tests[index].unit[a].value === null) || (delay === true && tests[index].delay.value === null)) {
                            failure.push(`     DOM node is not null: ${vars.text.cyan + result[a][2] + vars.text.none}`);
                        } else if ((delay === false && tests[index].unit[a].value === undefined) || (delay === true && tests[index].delay.value === undefined)) {
                            failure.push(`     DOM node is not undefined: ${vars.text.cyan + result[a][2] + vars.text.none}`);
                        } else {
                            failure.push(`     DOM node is ${result[a][1]}: ${vars.text.cyan + result[a][2] + vars.text.none}`);
                        }
                    },
                    failure:string[] = [];

                if (browser.index < index) {
                    browser.index = index;
                    if (result[0][0] === false && result[0][1] === "delay timeout") {
                        failure.push(testString(false, tests[index].delay));
                        if (tests[index].delay.type === "element") {
                            const qualifier:string = (tests[index].delay.qualifier === "not")
                                ? " not"
                                : "";
                            failure.push(`     DOM node is${qualifier} ${tests[index].delay.value}: ${vars.text.cyan + result[1][1] + vars.text.none}`);
                        } else {
                            failure.push(`     ${vars.text.green}Actual value:${vars.text.none}\n${vars.text.cyan + result[1][1].replace(/^"/, "").replace(/"$/, "").replace(/\\"/g, "\"") + vars.text.none}`);
                        }
                        falseFlag = true;
                    } else if (result[0][0] === false && result[0][1].indexOf("event error ") === 0) {
                        failure.push(`${vars.text.angry}Failed: event node is ${result[0][1].replace("event error ", "")}`);
                        failure.push(`     Specified event node is: ${vars.text.cyan + result[0][2] + vars.text.none}`);
                        falseFlag = true;
                    } else if (delay === true) {
                        failure.push(testString(result[a][0], tests[index].delay));
                        if (result[a][0] === false) {
                            failureMessage();
                            falseFlag = true;
                        }
                    } else {
                        do {
                            failure.push(testString(result[a][0], tests[index].unit[a]));
                            if (result[a][0] === false) {
                                failureMessage();
                                falseFlag = true;
                            }
                            a = a + 1;
                        } while (a < length);
                    }

                    if (falseFlag === true) {
                        failure.splice(0, 0, summary(false));
                        log(failure);
                        completion(false);
                        return;
                    }
                    log([summary(true)]);
                    if (index + 1 < tests.length) {
                        browser.methods.iterate(index + 1);
                    } else {
                        completion(true);
                    }
                }
            },
            route: function terminal_test_application_browser_route(socketData:socketData):void {
                const data:service_testBrowser = socketData.data as service_testBrowser;

                if (vars.settings.verbose === true) {
                    log([`On terminal receiving test index ${data.index}`]);
                }
                if (data.action !== "nothing" && data.action !== "reset-response") {
                    if (browser.methods[data.action] === undefined) {
                        error([`Unsupported action in browser test automation: ${data.action}`]);
                    } else if (browser.args.mode === "remote" && data.action === "result") {
                        data.test = {
                            interaction: null,
                            machine: "self",
                            name: `Report result to test ${data.index}.`,
                            unit: null
                        };
                        browser.methods.send(data, null);
                    } else {
                        browser.methods[data.action](data);
                    }
                } else if (data.exit !== "") {
                    log([data.exit]);
                }
                // close
                // * tells the test browser to close
                // * from browser.exit on primary computer sent to remotes
                // -
                // request
                // * sends a test from control computer to a specified remote
                // * from browser.iterate
                // * sends an unused HTTP response
                // -
                // reset-browser
                // * indicates, on a remote, the environment is reset and the browser is ready on the local computer
                // * from the browser
                // * send an HTTP request to data.transfer identifiers
                // -
                // reset-complete
                // * on primary computer confirms all the remote computers are reset and their web browsers are ready to execute
                // * from resetResponse of remote sent to primary computer
                // * executes local reset-request thus beginning test iteration
                // -
                // reset-request
                // * resets the environment on remotes
                // * from primary computer in browser.execute to the remotes
                // * generates an HTTP response
                // -
                // respond
                // * converts an action 'request' into a test for the browser of a specified remote
                // * from browser.request of remote
                // * sends an HTTP request to browser.ip with the test result
                // -
                // result
                // * response to test completion
                // * from browsers whether local or remote
                // * calls browser.iterate
            },
            send: function terminal_test_application_browser_send(testItem:service_testBrowser, callback:() => void):void {
                if (vars.settings.verbose === true) {
                    log([`On terminal sending test index ${testItem.index}`]);
                }
                if (testItem.test.machine === browser.name) {
                    const keys:string[] = Object.keys(transmit_ws.clientList.browser),
                        keyLength:number = keys.length;
                    if (keyLength > 0) {
                        sender.send({
                            data: testItem,
                            service: "test-browser"
                        }, {
                            device: keys[keys.length - 1],
                            user: "browser"
                        });
                    }
                } else {
                    const httpTemplate:config_http_request = {
                        agent: "",
                        agentType: "device",
                        callback: callback,
                        ip: machines[testItem.test.machine].ip,
                        port: machines[testItem.test.machine].port,
                        payload: {
                            data: testItem,
                            service: "test-browser"
                        },
                        stream: false
                    };
                    transmit_http.request(httpTemplate);
                }

                // Once a reset test is sent it is necessary to eliminate the event portion of the test.
                // This ensures the test available to the page upon page refresh for test unit evaluation without further executing the refresh event.
                if (testItem.test !== null && testItem.test.interaction !== null && testItem.test.interaction[0].event === "refresh") {
                    vars.test.browser.test.interaction = null;
                }
            }
        },
        name: (function terminal_test_application_browser_name():string {
            const keys:string[] = Object.keys(machines);
            let ipIndex:number = 0,
                machineIndex:number = keys.length;
            do {
                machineIndex = machineIndex - 1;
                ipIndex = vars.network.addresses.IPv4.length;
                do {
                    ipIndex = ipIndex - 1;
                    if (machines[keys[machineIndex]].ip === vars.network.addresses.IPv4[ipIndex]) {
                        return keys[machineIndex];
                    }
                } while (ipIndex > 0);
            } while (machineIndex > 0);
        }()),
        port: 0,
        remoteAgents: 0
    };

export default browser;